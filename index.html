<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyber Mahjong 64</title>
    <style>
        :root {
            --bg-color: #020205; --tile-bg: #111125;
            --color-1: #00f3ff; --color-2: #ff00ff;
            --color-3: #00ff66; --color-4: #ffcc00;
        }
        body {
            background-color: var(--bg-color); color: #fff;
            font-family: 'Consolas', monospace; margin: 0; padding: 0;
            display: flex; flex-direction: column; align-items: center;
            height: 100vh; overflow: hidden; touch-action: manipulation;
        }
        #matrix-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; opacity: 0.2; }
        #ui { height: 50px; display: flex; align-items: center; justify-content: center; font-size: 1rem; color: var(--color-1); z-index: 100; text-shadow: 0 0 10px var(--color-1); }
        #game-view { position: relative; width: 100%; flex-grow: 1; perspective: 1000px; }
        #tile-container { position: absolute; width: 100%; height: 100%; }
        #particle-container { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 2000; }

        .tile {
            position: absolute; background: var(--tile-bg); border: 1px solid #444; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            box-sizing: border-box; filter: brightness(0.6);
            /* 立体感を出すための影と側面表現 */
            box-shadow: 
                -1px 1px 0 #222,
                -2px 2px 0 #222,
                -3px 3px 5px rgba(0,0,0,0.8);
            transition: transform 0.1s, filter 0.2s;
        }
        /* 上の階層ほど明るく、影を深くして立体感を強調 */
        .tile[data-z="1"] { filter: brightness(0.8); transform: translate(-4px, -4px); box-shadow: -4px 4px 8px rgba(0,0,0,0.8); }
        .tile[data-z="2"] { filter: brightness(1.0); transform: translate(-8px, -8px); box-shadow: -8px 8px 12px rgba(0,0,0,0.9); }

        .tile.selected {
            filter: brightness(1.3) !important; border: 1.5px solid white;
            box-shadow: 0 0 20px var(--glow-color); z-index: 1500 !important;
            transform: translate(-10px, -10px) scale(1.05) !important;
        }
        .tile svg { width: 75%; height: 75%; pointer-events: none; }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none;
            flex-direction: column; align-items: center; justify-content: center; z-index: 9999;
            backdrop-filter: blur(5px);
        }
        .btn {
            background: none; border: 2px solid var(--color-1); color: var(--color-1);
            padding: 15px 40px; font-size: 1.2rem; cursor: pointer; margin-top: 20px;
            text-transform: uppercase; letter-spacing: 2px;
        }
        .btn:hover { background: var(--color-1); color: #000; }
    </style>
</head>
<body>

<canvas id="matrix-bg"></canvas>
<div id="ui">SYSTEM_NODES: <span id="counter">64</span> | MOVES: <span id="moves">?</span></div>
<div id="game-view">
    <div id="tile-container"></div>
    <div id="particle-container"></div>
</div>

<div id="complete-screen" class="overlay">
    <h1 style="color: var(--color-3); font-size: 3rem; text-shadow: 0 0 20px var(--color-3);">SYSTEM CLEARED</h1>
    <button class="btn" onclick="location.reload()">INITIALIZE</button>
</div>

<div id="fail-screen" class="overlay">
    <h1 style="color: var(--color-2); font-size: 3rem; text-shadow: 0 0 20px var(--color-2);">DEADLOCK DETECTED</h1>
    <button class="btn" onclick="location.reload()">REBOOT</button>
</div>

<script>
    let TILE_W, TILE_H, GAP_X, GAP_Y;
    
    function updateScale() {
        const isMobile = window.innerWidth < 600;
        const vh = document.getElementById('game-view').offsetHeight;
        const vw = window.innerWidth;
        
        // PCでもスマホでも画面の高さ・幅の小さい方に合わせる
        const base = Math.min(vw / 10, vh / 8);
        TILE_W = Math.floor(base);
        TILE_H = Math.floor(TILE_W * 1.3);
        GAP_X = TILE_W + (isMobile ? 2 : 5);
        GAP_Y = TILE_H + (isMobile ? 2 : 5);
    }

    function getOffsets() {
        const boardW = 7 * GAP_X + TILE_W;
        const boardH = 5 * GAP_Y + TILE_H;
        return {
            x: (window.innerWidth - boardW) / 2,
            y: (document.getElementById('game-view').offsetHeight - boardH) / 2
        };
    }

    let audioCtx = null;
    function playSound(type) {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        if (type === 'select') { osc.frequency.setValueAtTime(880, now); gain.gain.setValueAtTime(0.15, now); osc.start(); osc.stop(now + 0.08); }
        else if (type === 'match') { osc.type = 'square'; osc.frequency.setValueAtTime(600, now); osc.frequency.exponentialRampToValueAtTime(1200, now + 0.15); gain.gain.setValueAtTime(0.1, now); osc.start(); osc.stop(now + 0.15); }
    }

    const canvas = document.getElementById('matrix-bg');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', () => { resizeCanvas(); updateScale(); render(); });
    resizeCanvas();
    const alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const rainDrops = Array.from({length: 100}).map(() => 1);
    setInterval(() => {
        ctx.fillStyle = 'rgba(2, 2, 5, 0.1)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0F6'; ctx.font = '15px monospace';
        rainDrops.forEach((y, i) => {
            ctx.fillText(alphabet[Math.floor(Math.random()*alphabet.length)], i*20, y*15);
            if(y*15 > canvas.height && Math.random() > 0.975) rainDrops[i] = 0;
            rainDrops[i]++;
        });
    }, 50);

    const PATH_LIST = ["M12 2L2 19h20L12 2z", "M3 3h18v18H3V3z", "M12 22a10 10 0 1 0 0-20 10 10 0 0 0 0 20z", "M12 2l3.1 6.3 6.9 1-5 4.9 1.2 6.9-6.2-3.3-6.2 3.3 1.2-6.9-5-4.9 6.9-1L12 2z", "M12 1L3 5v6c0 5.5 3.8 10.7 9 12 5.2-1.3 9-6.5 9-12V5l-9-4z", "M13 2L3 14h9l-1 9 10-12h-9l1-9z", "M12 2c-4 0-8 3.6-8 8 0 5.4 8 12 8 12s8-6.6 8-12c0-4.4-3.6-8-8-8z", "M21 4H3v16h18V4zM5 18V6h14v12H5z", "M12 1l-9 9 9 9 9-9-9-9z", "M18 4l2 2-8 8-8-8 2-2 6 6 6-6z", "M4 4h7v7H4V4zm9 0h7v7h-7V4zm0 9h7v7h-7v-7zm-9 0h7v7H4v-7z", "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z", "M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z", "M11 7h2v2h-2V7zm0 4h2v6h-2v-6zm1-9C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z", "M12 6v3l4-4-4-4v3c-4.4 0-8 3.6-8 8 0 1.5.4 2.9 1.1 4l1.4-1.4c-.4-.8-.6-1.7-.6-2.6 0-3.3 2.7-6 6-6z", "M13 3h-2v10h2V3zm4.8 1.5l-1.4 1.4C17.9 7.3 19 9.5 19 12c0 3.9-3.1 7-7 7s-7-3.1-7-7c0-2.5 1.1-4.7 2.6-6.1L6.2 4.5C4.3 6.4 3 9.1 3 12c0 5 4 9 9 9s9-4 9-9c0-2.9-1.3-5.6-3.2-7.5z"];
    const COLORS = ["var(--color-1)", "var(--color-2)", "var(--color-3)", "var(--color-4)"];
    let tilesData = []; let selectedTile = null; let remaining = 64;

    function isSelectable(tile, currentTiles) {
        const {x, y, z} = tile;
        const onTop = currentTiles.some(t => t.z > z && Math.abs(t.x - x) < 0.7 && Math.abs(t.y - y) < 0.7);
        if (onTop) return false;
        const leftB = currentTiles.some(t => t.z === z && t.x === x - 1 && t.y === y);
        const rightB = currentTiles.some(t => t.z === z && t.x === x + 1 && t.y === y);
        return !leftB || !rightB;
    }

    function generateBoard() {
        const layout = [];
        for(let i=0; i<8; i++) for(let j=0; j<6; j++) layout.push({x: i, y: j, z: 0});
        for(let i=0; i<4; i++) for(let j=0; j<3; j++) layout.push({x: i+2, y: j+1.5, z: 1});
        for(let i=0; i<2; i++) for(let j=0; j<2; j++) layout.push({x: i+3, y: j+2, z: 2});
        const pool = [];
        for(let i=0; i<16; i++) {
            const p = { d: PATH_LIST[i], c: COLORS[i % 4] };
            pool.push(p, p, p, p);
        }
        let board = []; let tempSlots = [...layout];
        while (tempSlots.length > 0) {
            let candidates = tempSlots.filter(s => isSelectable(s, tempSlots));
            if (candidates.length < 2) candidates = [tempSlots[0], tempSlots[1]];
            let slot = candidates.splice(Math.floor(Math.random()*candidates.length), 1)[0];
            tempSlots = tempSlots.filter(s => s !== slot);
            const pattern = pool.splice(Math.floor(Math.random()*pool.length), 1)[0];
            board.push({ ...slot, icon: pattern.d, color: pattern.c, id: board.length, removed: false });
        }
        return board;
    }

    function handleTileClick(tile) {
        playSound('select');
        const active = tilesData.filter(t => !t.removed);
        if (!isSelectable(tile, active)) return;
        if (!selectedTile) { tile.selected = true; selectedTile = tile; }
        else if (selectedTile.id === tile.id) { tile.selected = false; selectedTile = null; }
        else if (selectedTile.icon === tile.icon && selectedTile.color === tile.color) {
            tile.removed = selectedTile.removed = true; selectedTile = null; remaining -= 2; playSound('match');
        } else { selectedTile.selected = false; tile.selected = true; selectedTile = tile; }
        render();
    }

    function checkMoves() {
        const active = tilesData.filter(t => !t.removed);
        const selectable = active.filter(t => isSelectable(t, active));
        let count = 0; const counts = {};
        selectable.forEach(t => { const k = t.icon + t.color; counts[k] = (counts[k] || 0) + 1; });
        for (let k in counts) count += Math.floor(counts[k]/2);
        return count;
    }

    function render() {
        const container = document.getElementById('tile-container');
        container.innerHTML = '';
        const off = getOffsets();
        tilesData.forEach(tile => {
            if (tile.removed) return;
            const el = document.createElement('div');
            el.className = `tile ${tile.selected ? 'selected' : ''}`;
            el.setAttribute('data-z', tile.z); // CSSで立体感を出し分ける
            el.style.width = TILE_W + 'px'; el.style.height = TILE_H + 'px';
            el.style.left = (tile.x * GAP_X + off.x) + 'px';
            el.style.top = (tile.y * GAP_Y + off.y) + 'px';
            el.style.zIndex = tile.z * 10;
            el.style.setProperty('--glow-color', tile.color);
            el.innerHTML = `<svg viewBox="0 0 24 24"><path d="${tile.icon}" fill="${tile.color}"></path></svg>`;
            el.onclick = () => handleTileClick(tile);
            container.appendChild(el);
        });
        const m = checkMoves();
        document.getElementById('counter').innerText = remaining;
        document.getElementById('moves').innerText = m;
        // 判定
        if (remaining === 0) document.getElementById('complete-screen').style.display = 'flex';
        else if (m === 0) document.getElementById('fail-screen').style.display = 'flex';
    }

    updateScale();
    tilesData = generateBoard();
    render();
</script>
</body>
</html>
