<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyber Mahjong 64</title>
    <style>
        :root {
            --bg-color: #020205; --tile-bg: #111125;
            --color-1: #00f3ff; --color-2: #ff00ff;
            --color-3: #00ff66; --color-4: #ffcc00;
        }
        body {
            background-color: var(--bg-color); color: #fff;
            font-family: 'Consolas', 'Courier New', "HiraMinProN-W6", "YuMincho", serif;
            margin: 0; padding: 0; display: flex; flex-direction: column; align-items: center;
            height: 100vh; width: 100vw; overflow: hidden; touch-action: manipulation;
        }
        #matrix-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; opacity: 0.35; }
        
        #ui { 
            padding: 20px 0; display: flex; flex-direction: column; align-items: center;
            z-index: 100; background: rgba(0,0,0,0.85); width: 100%; border-bottom: 5px solid var(--color-1);
            box-shadow: 0 10px 40px rgba(0,243,255,0.5); transition: opacity 0.5s;
        }
        #title-text {
            font-size: clamp(1.5rem, 5vw, 4rem); font-weight: 900; color: var(--color-1); 
            letter-spacing: 0.5rem; text-align: center; text-shadow: 0 0 30px var(--color-1);
            margin: 0 0 10px 0; line-height: 1;
        }
        #status-row { display: flex; gap: 50px; justify-content: center; width: 100%; }
        .stat-box { display: flex; flex-direction: column; align-items: center; }
        .stat-label {
            font-size: clamp(1rem, 2vw, 1.5rem); color: #fff; font-weight: bold; letter-spacing: 0.2rem; opacity: 0.9;
        }
        .stat-value {
            font-size: clamp(2.5rem, 8vw, 6rem); font-weight: 900; line-height: 1; text-shadow: 0 0 30px currentColor;
        }

        #game-view { position: relative; width: 100%; flex-grow: 1; perspective: 1500px; opacity: 0; transition: opacity 1s; }
        #tile-container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; }

        /* 漢字タイル設定 */
        .tile {
            position: absolute; background: var(--tile-bg); border: 2px solid #555; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            box-sizing: border-box; filter: brightness(0.8);
            box-shadow: -4px 4px 0 #222, -8px 8px 20px rgba(0,0,0,0.9);
            cursor: pointer; transition: transform 0.1s, filter 0.1s;
        }
        .tile[data-z="1"] { transform: translate(-8px, -8px); filter: brightness(1.0); }
        .tile[data-z="2"] { transform: translate(-16px, -16px); filter: brightness(1.2); }
        .tile.selected {
            filter: brightness(1.5) !important; border: 4px solid #fff;
            box-shadow: 0 0 60px var(--glow-color), inset 0 0 20px var(--glow-color); 
            z-index: 1000 !important; transform: translate(-20px, -20px) scale(1.15) !important;
        }
        .tile-text {
            font-weight: 900; fill: var(--glow-color); filter: drop-shadow(0 0 5px var(--glow-color)); user-select: none;
        }

        /* オーバーレイ共通設定 */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: none;
            flex-direction: column; align-items: center; justify-content: center; z-index: 9999;
        }
        .overlay h1 { font-size: clamp(4rem, 15vw, 12rem); margin: 0; text-shadow: 0 0 50px currentColor; text-align: center; }
        .btn { 
            background: none; border: 4px solid var(--color-1); color: var(--color-1); 
            padding: 20px 60px; font-size: clamp(1.5rem, 3vw, 3rem); cursor: pointer; margin-top: 40px; transition: 0.3s;
        }
        .btn:hover { background: var(--color-1); color: #000; box-shadow: 0 0 50px var(--color-1); }

        /* 開始カットイン専用 */
        #start-screen { display: flex; background: rgba(0,0,0,1); } /* 最初は真っ黒で表示 */
        #start-title {
            font-size: clamp(5rem, 20vw, 15rem); color: #fff; font-weight: 900;
            text-shadow: 0 0 50px var(--color-1), 0 0 100px var(--color-1);
            letter-spacing: 1rem; margin-bottom: 50px;
            animation: textGlitch 3s infinite alternate;
        }
        @keyframes textGlitch {
            0% { text-shadow: 0 0 50px var(--color-1), 5px 0 5px var(--color-2); }
            100% { text-shadow: 0 0 70px var(--color-1), -5px 0 5px var(--color-3); transform: scale(1.02); }
        }
        .fade-out { animation: fadeOutEffect 1s forwards; pointer-events: none; }
        @keyframes fadeOutEffect { to { opacity: 0; visibility: hidden; } }
        .fade-in { opacity: 1 !important; }
    </style>
</head>
<body>

<audio id="bgm" loop preload="auto">
    <source src="assets/sounds/midnight-rush.mp3" type="audio/mpeg">
    </audio>

<canvas id="matrix-bg"></canvas>

<div id="start-screen" class="overlay">
    <div id="start-title"><p style="text-align:center">電脳麻雀<br>CYBER MAHJONG</p></div>
    <button class="btn" onclick="startGame()"><p style="text-align:center">JACK IN TO SYSTEM</p></button>
</div>

<div id="ui">
    <div id="title-text"><h1>CYBER MAHJONG 64</h1><br>
    Remove all tiles by matching pairs</div>
    <div id="status-row">
        <div class="stat-box"><span class="stat-label"><h2>TILES</h2></span><span id="counter" class="stat-value" style="color:var(--color-3)">64</span></div>
        <div class="stat-box"><span class="stat-label"><h2>PAIRS</h2></h2></span><span id="moves" class="stat-value" style="color:var(--color-4)">?</span></div>
    </div>
</div>

<div id="game-view"><div id="tile-container"></div></div>

<div id="complete-screen" class="overlay"><h1 style="color: var(--color-3);">COMPLETE<br>Keyword : Tiles</h1><button class="btn" onclick="location.reload()">REBOOT</button></div>
<div id="fail-screen" class="overlay"><h1 style="color: var(--color-2);">FAILED</h1><button class="btn" onclick="location.reload()">RESTART</button></div>

<script>
    // --- グローバル変数 ---
    let TILE_W, TILE_H, GAP_X, GAP_Y;
    let audioCtx = null;
    const bgmElement = document.getElementById('bgm'); // BGM要素を取得

    // --- ゲーム開始処理（カットイン＆BGM開始） ---
    function startGame() {
        // 1. AudioContextの初期化（効果音用）
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        
        // 2. BGMの再生開始
        // BGMファイルが設定されている場合のみ再生を試みる
        if (bgmElement.currentSrc) {
            bgmElement.volume = 0.3; // 音量を30%に設定（お好みで調整）
            bgmElement.play().catch(e => console.log("BGM playback failed:", e));
        }

        // 開始音を鳴らす
        playSound('start');

        // 3. カットインをフェードアウトさせてゲーム画面を表示
        document.getElementById('start-screen').classList.add('fade-out');
        document.getElementById('game-view').classList.add('fade-in');
        
        // Matrix背景の描画開始
        if(!matrixInterval) matrixInterval = setInterval(drawMatrix, 50);
    }

    // --- Audio System (効果音) ---
    function playSound(type) {
        if (!audioCtx) return; // 開始前は鳴らさない
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        if (type === 'start') {
            // 開始時のド派手な音
            osc.type='sawtooth'; osc.frequency.setValueAtTime(220, now); osc.frequency.exponentialRampToValueAtTime(880, now + 0.5); gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 1.0); osc.start(); osc.stop(now + 1.0);
        } else if (type === 'select') { 
            osc.frequency.setValueAtTime(1200, now); gain.gain.setValueAtTime(0.05, now); osc.start(); osc.stop(now + 0.05); 
        } else if (type === 'match') { 
            osc.type='triangle'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(800, now + 0.1); gain.gain.setValueAtTime(0.05, now); osc.start(); osc.stop(now + 0.2); 
        }
    }

    // --- Matrix Background ---
    const canvas = document.getElementById('matrix-bg');
    const ctx = canvas.getContext('2d');
    ctx.scale(-1, 1); let drops = []; const fontSize = window.innerWidth > 1000 ? 100 : 40;
    let matrixInterval = null; // タイマー管理用

    function initMatrix() {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        const columns = Math.ceil(canvas.width / fontSize);
        drops = Array(columns).fill(0).map(() => Math.random() * -50);
    }
    function drawMatrix() {
        ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.fillStyle = 'rgba(2, 2, 5, 0.2)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.setTransform(-1, 0, 0, 1, canvas.width, 0); ctx.fillStyle = '#0F6'; ctx.font = `bold ${fontSize}px monospace`;
        for(let i = 0; i < drops.length; i++) {
            const text = String.fromCharCode(Math.random() > 0.5 ? (0x30A0 + Math.random() * 96) : (0x0030 + Math.random() * 10));
            ctx.fillText(text, i * fontSize, drops[i] * fontSize);
            if (drops[i] * fontSize > canvas.height && Math.random() > 0.99) drops[i] = 0;
            drops[i]++;
        }
    }

    // --- Game Logic (漢字版) ---
    let TILE_W_VAL, TILE_H_VAL; // 値保持用
    function updateScale() {
        const vw = window.innerWidth; const vh = document.getElementById('game-view').offsetHeight || window.innerHeight;
        const marginFactor = vw > 1000 ? 0.7 : 0.9;
        const maxBoardW = vw * marginFactor; const maxBoardH = vh * 0.75;
        TILE_W_VAL = Math.min(maxBoardW / 8 * 0.9, maxBoardH / 6 * 0.7); TILE_H_VAL = TILE_W_VAL * 1.35;
        TILE_W = TILE_W_VAL + 'px'; TILE_H = TILE_H_VAL + 'px';
        GAP_X = TILE_W_VAL + (vw > 600 ? 12 : 3); GAP_Y = TILE_H_VAL + (vw > 600 ? 12 : 3);
    }
    function getOffsets() {
        const boardW = 7 * GAP_X + TILE_W_VAL; const boardH = 5 * GAP_Y + TILE_H_VAL;
        const gv = document.getElementById('game-view');
        return { x: (window.innerWidth - boardW) / 2, y: (gv.offsetHeight - boardH) / 2 };
    }

    const CHAR_LIST = ["一", "二", "三", "四", "五", "六", "七", "八", "九", "東", "南", "西", "北", "白", "發", "中"];
    const COLORS = ["var(--color-1)", "var(--color-2)", "var(--color-3)", "var(--color-4)"];
    let tilesData = []; let selectedTile = null; let remaining = 64;

    function isSelectable(tile, currentTiles) {
        const {x, y, z} = tile;
        const onTop = currentTiles.some(t => t.z > z && Math.abs(t.x - x) < 0.7 && Math.abs(t.y - y) < 0.7);
        if (onTop) return false;
        const leftB = currentTiles.some(t => t.z === z && t.x === x - 1 && t.y === y);
        const rightB = currentTiles.some(t => t.z === z && t.x === x + 1 && t.y === y);
        return !leftB || !rightB;
    }

    function generateBoard() {
        const layout = [];
        for(let i=0; i<8; i++) for(let j=0; j<6; j++) layout.push({x: i, y: j, z: 0});
        for(let i=0; i<4; i++) for(let j=0; j<3; j++) layout.push({x: i+2, y: j+1.5, z: 1});
        for(let i=0; i<2; i++) for(let j=0; j<2; j++) layout.push({x: i+3, y: j+2, z: 2});
        const pool = [];
        for(let i=0; i<16; i++) { const p = { char: CHAR_LIST[i], c: COLORS[i % 4] }; pool.push(p, p, p, p); }
        let board = []; let tempSlots = [...layout];
        while (tempSlots.length > 0) {
            let candidates = tempSlots.filter(s => isSelectable(s, tempSlots));
            if (candidates.length < 2) candidates = [tempSlots[0], tempSlots[1]];
            let slot = candidates.splice(Math.floor(Math.random()*candidates.length), 1)[0];
            tempSlots = tempSlots.filter(s => s !== slot);
            const pattern = pool.splice(Math.floor(Math.random()*pool.length), 1)[0];
            board.push({ ...slot, char: pattern.char, color: pattern.c, id: board.length, removed: false });
        }
        return board;
    }

    function checkMoves() {
        const active = tilesData.filter(t => !t.removed);
        const selectable = active.filter(t => isSelectable(t, active));
        let count = 0; const counts = {};
        selectable.forEach(t => { const k = t.char + t.color; counts[k] = (counts[k] || 0) + 1; });
        for (let k in counts) count += Math.floor(counts[k]/2);
        return count;
    }

    function render() {
        const container = document.getElementById('tile-container');
        container.innerHTML = '';
        const off = getOffsets();
        tilesData.forEach(tile => {
            if (tile.removed) return;
            const el = document.createElement('div');
            el.className = `tile ${tile.selected ? 'selected' : ''}`;
            el.setAttribute('data-z', tile.z);
            el.style.width = TILE_W; el.style.height = TILE_H;
            el.style.left = (tile.x * GAP_X + off.x) + 'px';
            el.style.top = (tile.y * GAP_Y + off.y) + 'px';
            el.style.zIndex = tile.z * 10;
            el.style.setProperty('--glow-color', tile.color);
            el.innerHTML = `<svg viewBox="0 0 100 100" width="100%" height="100%"><text x="50" y="58" text-anchor="middle" dominant-baseline="middle" class="tile-text" font-size="70" fill="${tile.color}">${tile.char}</text></svg>`;
            el.onclick = () => { playSound('select'); handleTileClick(tile); };
            container.appendChild(el);
        });
        const m = checkMoves();
        document.getElementById('counter').innerText = remaining;
        document.getElementById('moves').innerText = m;
        if (remaining === 0) document.getElementById('complete-screen').style.display = 'flex';
        else if (m === 0) document.getElementById('fail-screen').style.display = 'flex';
    }

    function handleTileClick(tile) {
        const active = tilesData.filter(t => !t.removed);
        if (!isSelectable(tile, active)) return;
        if (!selectedTile) { tile.selected = true; selectedTile = tile; }
        else if (selectedTile.id === tile.id) { tile.selected = false; selectedTile = null; }
        else if (selectedTile.char === tile.char && selectedTile.color === tile.color) {
            tile.removed = selectedTile.removed = true; selectedTile = null; remaining -= 2; playSound('match');
        } else { selectedTile.selected = false; tile.selected = true; selectedTile = tile; }
        render();
    }

    // 初期化フロー
    window.addEventListener('resize', () => { initMatrix(); updateScale(); render(); });
    initMatrix();
    // Matrix描画はstartGame()で開始する
    updateScale();
    tilesData = generateBoard();
    render();
    // ゲーム画面は最初は隠しておく
    document.getElementById('game-view').style.opacity = 0;
</script>
</body>
</html>










