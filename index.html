<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyber Mahjong 64</title>
    <style>
        :root {
            --bg-color: #020205; --tile-bg: #111125;
            --color-1: #00f3ff; --color-2: #ff00ff;
            --color-3: #00ff66; --color-4: #ffcc00;
        }
        body {
            background-color: var(--bg-color); color: #fff;
            font-family: 'Consolas', monospace; margin: 0; padding: 0;
            display: flex; flex-direction: column; align-items: center;
            height: 100vh; width: 100vw; overflow: hidden; touch-action: manipulation;
        }
        #matrix-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; opacity: 0.3; }
        
        #ui { 
            height: 60px; display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 1rem; color: var(--color-1); z-index: 100;
            background: rgba(0,0,0,0.7); width: 100%;
        }

        #game-view { position: relative; width: 100%; flex-grow: 1; perspective: 1000px; }
        #tile-container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; }

        .tile {
            position: absolute; background: var(--tile-bg); border: 1px solid #444; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            box-sizing: border-box; filter: brightness(0.6);
            box-shadow: -1px 1px 0 #333, -3px 3px 6px rgba(0,0,0,0.8);
            cursor: pointer;
        }
        .tile[data-z="1"] { transform: translate(-4px, -4px); filter: brightness(0.85); }
        .tile[data-z="2"] { transform: translate(-8px, -8px); filter: brightness(1.1); }

        .tile.selected {
            filter: brightness(1.4) !important; border: 2px solid #fff;
            box-shadow: 0 0 25px var(--glow-color); z-index: 1000 !important;
            transform: translate(-10px, -10px) scale(1.1) !important;
        }
        .tile svg { width: 70%; height: 70%; pointer-events: none; }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none;
            flex-direction: column; align-items: center; justify-content: center; z-index: 9999;
        }
        .btn { background: none; border: 2px solid var(--color-1); color: var(--color-1); padding: 15px 30px; cursor: pointer; }
    </style>
</head>
<body>

<canvas id="matrix-bg"></canvas>
<div id="ui">
    <div>SYSTEM_NODES: <span id="counter">64</span> / 64</div>
    <div style="font-size: 0.8rem; opacity: 0.7;">PAIRS: <span id="moves">?</span></div>
</div>
<div id="game-view">
    <div id="tile-container"></div>
</div>

<div id="complete-screen" class="overlay"><h1>CLEARED</h1><button class="btn" onclick="location.reload()">REBOOT</button></div>
<div id="fail-screen" class="overlay"><h1>DEADLOCK</h1><button class="btn" onclick="location.reload()">RESTART</button></div>

<script>
    let TILE_W, TILE_H, GAP_X, GAP_Y;
    
    function updateScale() {
        const vw = window.innerWidth;
        const vh = document.getElementById('game-view').offsetHeight;
        
        // 修正：スマホでも左右にMatrixが見えるよう、画面幅の80%を上限にする
        const maxBoardW = vw * 0.85; 
        const maxBoardH = vh * 0.85;

        // 8列6行が収まるサイズを逆算
        const unitW = maxBoardW / 8;
        const unitH = maxBoardH / 6;

        TILE_W = Math.min(unitW * 0.9, unitH * 0.7); // アスペクト比を維持
        TILE_H = TILE_W * 1.35;
        
        // PCでも表示されるよう制限を緩和
        GAP_X = TILE_W + (vw > 600 ? 5 : 2);
        GAP_Y = TILE_H + (vw > 600 ? 5 : 2);
    }

    function getOffsets() {
        const boardW = 7 * GAP_X + TILE_W;
        const boardH = 5 * GAP_Y + TILE_H;
        return {
            x: (window.innerWidth - boardW) / 2,
            y: (document.getElementById('game-view').offsetHeight - boardH) / 2
        };
    }

    // --- Matrix Background (負荷軽減 & 全画面修正) ---
    const canvas = document.getElementById('matrix-bg');
    const ctx = canvas.getContext('2d');
    let drops = [];
    const fontSize = 24; // 文字を大きくして描画回数を減らす（負荷軽減）

    function initMatrix() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const columns = Math.ceil(canvas.width / fontSize);
        drops = Array(columns).fill(0).map(() => Math.random() * canvas.height / fontSize);
    }

    function drawMatrix() {
        ctx.fillStyle = 'rgba(2, 2, 5, 0.15)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0F6';
        ctx.font = fontSize + 'px monospace';
        for(let i = 0; i < drops.length; i++) {
            const text = String.fromCharCode(0x30A0 + Math.random() * 96);
            ctx.fillText(text, i * fontSize, drops[i] * fontSize);
            if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) drops[i] = 0;
            drops[i]++;
        }
    }

    // --- Audio ---
    let audioCtx = null;
    function playSound(type) {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        if (type === 'select') { osc.frequency.setValueAtTime(800, audioCtx.currentTime); gain.gain.setValueAtTime(0.1, audioCtx.currentTime); osc.start(); osc.stop(audioCtx.currentTime + 0.1); }
        else if (type === 'match') { osc.type='square'; osc.frequency.setValueAtTime(600, audioCtx.currentTime); gain.gain.setValueAtTime(0.1, audioCtx.currentTime); osc.start(); osc.stop(audioCtx.currentTime + 0.1); }
    }

    // --- Game Logic ---
    const PATH_LIST = ["M12 2L2 19h20L12 2z", "M3 3h18v18H3V3z", "M12 22a10 10 0 1 0 0-20 10 10 0 0 0 0 20z", "M12 2l3.1 6.3 6.9 1-5 4.9 1.2 6.9-6.2-3.3-6.2 3.3 1.2-6.9-5-4.9 6.9-1L12 2z", "M12 1L3 5v6c0 5.5 3.8 10.7 9 12 5.2-1.3 9-6.5 9-12V5l-9-4z", "M13 2L3 14h9l-1 9 10-12h-9l1-9z", "M12 2c-4 0-8 3.6-8 8 0 5.4 8 12 8 12s8-6.6 8-12c0-4.4-3.6-8-8-8z", "M21 4H3v16h18V4zM5 18V6h14v12H5z", "M12 1l-9 9 9 9 9-9-9-9z", "M18 4l2 2-8 8-8-8 2-2 6 6 6-6z", "M4 4h7v7H4V4zm9 0h7v7h-7V4zm0 9h7v7h-7v-7zm-9 0h7v7H4v-7z", "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z", "M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z", "M11 7h2v2h-2V7zm0 4h2v6h-2v-6zm1-9C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z", "M12 6v3l4-4-4-4v3c-4.4 0-8 3.6-8 8 0 1.5.4 2.9 1.1 4l1.4-1.4c-.4-.8-.6-1.7-.6-2.6 0-3.3 2.7-6 6-6z", "M13 3h-2v10h2V3zm4.8 1.5l-1.4 1.4C17.9 7.3 19 9.5 19 12c0 3.9-3.1 7-7 7s-7-3.1-7-7c0-2.5 1.1-4.7 2.6-6.1L6.2 4.5C4.3 6.4 3 9.1 3 12c0 5 4 9 9 9s9-4 9-9c0-2.9-1.3-5.6-3.2-7.5z"];
    const COLORS = ["var(--color-1)", "var(--color-2)", "var(--color-3)", "var(--color-4)"];
    let tilesData = []; let selectedTile = null; let remaining = 64;

    function isSelectable(tile, currentTiles) {
        const {x, y, z} = tile;
        const onTop = currentTiles.some(t => t.z > z && Math.abs(t.x - x) < 0.7 && Math.abs(t.y - y) < 0.7);
        if (onTop) return false;
        const leftB = currentTiles.some(t => t.z === z && t.x === x - 1 && t.y === y);
        const rightB = currentTiles.some(t => t.z === z && t.x === x + 1 && t.y === y);
        return !leftB || !rightB;
    }

    function generateBoard() {
        const layout = [];
        for(let i=0; i<8; i++) for(let j=0; j<6; j++) layout.push({x: i, y: j, z: 0});
        for(let i=0; i<4; i++) for(let j=0; j<3; j++) layout.push({x: i+2, y: j+1.5, z: 1});
        for(let i=0; i<2; i++) for(let j=0; j<2; j++) layout.push({x: i+3, y: j+2, z: 2});
        const pool = [];
        for(let i=0; i<16; i++) { const p = { d: PATH_LIST[i], c: COLORS[i % 4] }; pool.push(p, p, p, p); }
        let board = []; let tempSlots = [...layout];
        while (tempSlots.length > 0) {
            let candidates = tempSlots.filter(s => isSelectable(s, tempSlots));
            if (candidates.length < 2) candidates = [tempSlots[0], tempSlots[1]];
            let slot = candidates.splice(Math.floor(Math.random()*candidates.length), 1)[0];
            tempSlots = tempSlots.filter(s => s !== slot);
            const pattern = pool.splice(Math.floor(Math.random()*pool.length), 1)[0];
            board.push({ ...slot, icon: pattern.d, color: pattern.c, id: board.length, removed: false });
        }
        return board;
    }

    function checkMoves() {
        const active = tilesData.filter(t => !t.removed);
        const selectable = active.filter(t => isSelectable(t, active));
        let count = 0; const counts = {};
        selectable.forEach(t => { const k = t.icon + t.color; counts[k] = (counts[k] || 0) + 1; });
        for (let k in counts) count += Math.floor(counts[k]/2);
        return count;
    }

    function render() {
        const container = document.getElementById('tile-container');
        container.innerHTML = '';
        const off = getOffsets();
        tilesData.forEach(tile => {
            if (tile.removed) return;
            const el = document.createElement('div');
            el.className = `tile ${tile.selected ? 'selected' : ''}`;
            el.setAttribute('data-z', tile.z);
            el.style.width = TILE_W + 'px'; el.style.height = TILE_H + 'px';
            el.style.left = (tile.x * GAP_X + off.x) + 'px';
            el.style.top = (tile.y * GAP_Y + off.y) + 'px';
            el.style.zIndex = tile.z * 10;
            el.style.setProperty('--glow-color', tile.color);
            el.innerHTML = `<svg viewBox="0 0 24 24"><path d="${tile.icon}" fill="${tile.color}"></path></svg>`;
            el.onclick = () => { playSound('select'); handleTileClick(tile); };
            container.appendChild(el);
        });
        const m = checkMoves();
        document.getElementById('counter').innerText = remaining;
        document.getElementById('moves').innerText = m;
        if (remaining === 0) document.getElementById('complete-screen').style.display = 'flex';
        else if (m === 0) document.getElementById('fail-screen').style.display = 'flex';
    }

    function handleTileClick(tile) {
        const active = tilesData.filter(t => !t.removed);
        if (!isSelectable(tile, active)) return;
        if (!selectedTile) { tile.selected = true; selectedTile = tile; }
        else if (selectedTile.id === tile.id) { tile.selected = false; selectedTile = null; }
        else if (selectedTile.icon === tile.icon && selectedTile.color === tile.color) {
            tile.removed = selectedTile.removed = true; selectedTile = null; remaining -= 2; playSound('match');
        } else { selectedTile.selected = false; tile.selected = true; selectedTile = tile; }
        render();
    }

    window.addEventListener('resize', () => { initMatrix(); updateScale(); render(); });
    initMatrix();
    setInterval(drawMatrix, 60);
    updateScale();
    tilesData = generateBoard();
    render();
</script>
</body>
</html>
