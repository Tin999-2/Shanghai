<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyber Mahjong 64</title>
    <style>
        :root {
            --bg-color: #020205; --tile-bg: #111125;
            --color-1: #00f3ff; --color-2: #ff00ff;
            --color-3: #00ff66; --color-4: #ffcc00;
        }
        body {
            background-color: var(--bg-color); color: #fff;
            font-family: 'Consolas', 'Courier New', monospace; margin: 0; padding: 0;
            display: flex; flex-direction: column; align-items: center;
            height: 100vh; width: 100vw; overflow: hidden; touch-action: manipulation;
        }
        #matrix-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; opacity: 0.35; }
        
        #ui { 
            padding: 20px 0; display: flex; flex-direction: column; align-items: center;
            z-index: 100; background: rgba(0,0,0,0.85); width: 100%; border-bottom: 5px solid var(--color-1);
            box-shadow: 0 10px 40px rgba(0,243,255,0.5);
        }
        
        #title-text {
            font-size: clamp(2rem, 8vw, 6rem);
            font-weight: 900; color: var(--color-1); 
            letter-spacing: 1.2rem; text-align: center;
            text-shadow: 0 0 30px var(--color-1);
            margin: 0 0 15px 0; line-height: 1;
        }

        #status-row { display: flex; gap: 80px; justify-content: center; width: 100%; }
        .stat-box { display: flex; flex-direction: column; align-items: center; }
        .stat-label {
            font-size: clamp(1.2rem, 3vw, 2.5rem);
            color: #fff; font-weight: bold; letter-spacing: 0.4rem; 
            margin-bottom: 5px; opacity: 0.9;
        }
        .stat-value {
            font-size: clamp(3rem, 10vw, 8rem);
            font-weight: 900; line-height: 1;
            text-shadow: 0 0 30px currentColor;
        }

        #game-view { position: relative; width: 100%; flex-grow: 1; perspective: 1500px; }
        #tile-container { position: absolute; width: 100%; height: 100%; top: 0; left: 0; }

        .tile {
            position: absolute; background: var(--tile-bg); border: 2px solid #555; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            box-sizing: border-box; filter: brightness(0.8);
            box-shadow: -4px 4px 0 #222, -8px 8px 20px rgba(0,0,0,0.9);
            cursor: pointer; transition: transform 0.1s, filter 0.1s;
        }
        .tile[data-z="1"] { transform: translate(-8px, -8px); filter: brightness(1.0); }
        .tile[data-z="2"] { transform: translate(-16px, -16px); filter: brightness(1.2); }
        
        .tile.selected {
            filter: brightness(1.5) !important; border: 4px solid #fff;
            box-shadow: 0 0 60px var(--glow-color), inset 0 0 20px var(--glow-color); 
            z-index: 1000 !important;
            transform: translate(-20px, -20px) scale(1.15) !important;
        }
        
        /* 漢字表示用のスタイル */
        .tile-text {
            font-family: "HiraMinProN-W6", "YuMincho", serif; /* 麻雀牌らしいフォント */
            font-weight: 900;
            fill: var(--glow-color);
            filter: drop-shadow(0 0 5px var(--glow-color));
            user-select: none;
        }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: none;
            flex-direction: column; align-items: center; justify-content: center; z-index: 9999;
        }
        .overlay h1 { font-size: clamp(5rem, 25vw, 15rem); margin: 0; text-shadow: 0 0 50px currentColor; }
        .btn { 
            background: none; border: 5px solid var(--color-1); color: var(--color-1); 
            padding: 25px 80px; font-size: clamp(2rem, 4vw, 3.5rem); cursor: pointer; margin-top: 50px;
        }
    </style>
</head>
<body>

<canvas id="matrix-bg"></canvas>
<div id="ui">
    <div id="title-text">CYBER MAHJONG 64</div>
    <div id="status-row">
        <div class="stat-box">
            <span class="stat-label">NODES</span>
            <span id="counter" class="stat-value" style="color:var(--color-3)">64</span>
        </div>
        <div class="stat-box">
            <span class="stat-label">PAIRS</span>
            <span id="moves" class="stat-value" style="color:var(--color-4)">?</span>
        </div>
    </div>
</div>
<div id="game-view"><div id="tile-container"></div></div>

<div id="complete-screen" class="overlay"><h1 style="color: var(--color-3);">CLEARED</h1><button class="btn" onclick="location.reload()">REBOOT</button></div>
<div id="fail-screen" class="overlay"><h1 style="color: var(--color-2);">DEADLOCK</h1><button class="btn" onclick="location.reload()">RESTART</button></div>

<script>
    let TILE_W, TILE_H, GAP_X, GAP_Y;
    
    function updateScale() {
        const vw = window.innerWidth;
        const vh = document.getElementById('game-view').offsetHeight;
        const marginFactor = vw > 1000 ? 0.7 : 0.9;
        const maxBoardW = vw * marginFactor; 
        const maxBoardH = vh * 0.75;
        const unitW = maxBoardW / 8;
        const unitH = maxBoardH / 6;
        TILE_W = Math.min(unitW * 0.9, unitH * 0.7);
        TILE_H = TILE_W * 1.35;
        GAP_X = TILE_W + (vw > 600 ? 12 : 3);
        GAP_Y = TILE_H + (vw > 600 ? 12 : 3);
    }

    function getOffsets() {
        const boardW = 7 * GAP_X + TILE_W;
        const boardH = 5 * GAP_Y + TILE_H;
        return { x: (window.innerWidth - boardW) / 2, y: (document.getElementById('game-view').offsetHeight - boardH) / 2 };
    }

    // --- Matrix Background (左右反転 & 高密度) ---
    const canvas = document.getElementById('matrix-bg');
    const ctx = canvas.getContext('2d');
    
    // コンテキストを反転させることで文字を鏡文字にする
    ctx.scale(-1, 1); 
    
    let drops = [];
    const fontSize = window.innerWidth > 1000 ? 100 : 40; 

    function initMatrix() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // 反転しているので座標系も考慮が必要だが、簡易的に描画時に座標をマイナスにする手法をとるため
        // ここでは通常通りカラム計算を行う
        // 高密度にするため、フォントサイズに対するカラム密度を少し上げる計算にはしないが
        // 描画ループで文字を途切れさせない工夫をする
        const columns = Math.ceil(canvas.width / fontSize);
        drops = Array(columns).fill(0).map(() => Math.random() * -50); // 開始位置をさらに分散
    }

    function drawMatrix() {
        // 反転状態でのクリア処理
        ctx.setTransform(1, 0, 0, 1, 0, 0); // 一旦リセット
        ctx.fillStyle = 'rgba(2, 2, 5, 0.2)'; // 残像を長く残す（数値を小さく）
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.setTransform(-1, 0, 0, 1, canvas.width, 0); // 左右反転セット（右端が0になる）

        ctx.fillStyle = '#0F6';
        ctx.font = `bold ${fontSize}px monospace`;
        
        for(let i = 0; i < drops.length; i++) {
            // 文字種をカタカナ＋数字＋記号に
            const charCode = Math.random() > 0.5 ? (0x30A0 + Math.random() * 96) : (0x0030 + Math.random() * 10);
            const text = String.fromCharCode(charCode);
            
            // x座標は反転コンテキストなのでそのまま正の値でOK（右から左へ描画されるように見える）
            ctx.fillText(text, i * fontSize, drops[i] * fontSize);

            // 途切れさせない：画面下端を超えたら、ランダムに上に戻す確率を下げる（=長く垂らす）
            if (drops[i] * fontSize > canvas.height && Math.random() > 0.99) {
                drops[i] = 0;
            }
            drops[i]++;
        }
    }

    // --- Audio ---
    let audioCtx = null;
    function playSound(type) {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        if (type === 'select') { 
            osc.frequency.setValueAtTime(1200, audioCtx.currentTime); // 高い音
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime); 
            osc.start(); osc.stop(audioCtx.currentTime + 0.05); 
        } else if (type === 'match') { 
            osc.type='triangle'; 
            osc.frequency.setValueAtTime(400, audioCtx.currentTime); 
            osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1); // 上昇音
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime); 
            osc.start(); osc.stop(audioCtx.currentTime + 0.2); 
        }
    }

    // --- Logic: 漢字リストへ変更 ---
    // 16種類 (1-9, 東南西北, 白發中)
    const CHAR_LIST = [
        "一", "二", "三", "四", "五", "六", "七", "八", "九",
        "東", "南", "西", "北", "白", "發", "中"
    ];
    const COLORS = ["var(--color-1)", "var(--color-2)", "var(--color-3)", "var(--color-4)"];
    
    let tilesData = []; let selectedTile = null; let remaining = 64;

    function isSelectable(tile, currentTiles) {
        const {x, y, z} = tile;
        const onTop = currentTiles.some(t => t.z > z && Math.abs(t.x - x) < 0.7 && Math.abs(t.y - y) < 0.7);
        if (onTop) return false;
        const leftB = currentTiles.some(t => t.z === z && t.x === x - 1 && t.y === y);
        const rightB = currentTiles.some(t => t.z === z && t.x === x + 1 && t.y === y);
        return !leftB || !rightB;
    }

    function generateBoard() {
        const layout = [];
        for(let i=0; i<8; i++) for(let j=0; j<6; j++) layout.push({x: i, y: j, z: 0});
        for(let i=0; i<4; i++) for(let j=0; j<3; j++) layout.push({x: i+2, y: j+1.5, z: 1});
        for(let i=0; i<2; i++) for(let j=0; j<2; j++) layout.push({x: i+3, y: j+2, z: 2});
        
        const pool = [];
        // 16種類の漢字 x 4色 でペアを作る
        for(let i=0; i<16; i++) { 
            const p = { char: CHAR_LIST[i], c: COLORS[i % 4] }; 
            pool.push(p, p, p, p); // 4枚1組
        }
        
        let board = []; let tempSlots = [...layout];
        while (tempSlots.length > 0) {
            let candidates = tempSlots.filter(s => isSelectable(s, tempSlots));
            if (candidates.length < 2) candidates = [tempSlots[0], tempSlots[1]];
            let slot = candidates.splice(Math.floor(Math.random()*candidates.length), 1)[0];
            tempSlots = tempSlots.filter(s => s !== slot);
            const pattern = pool.splice(Math.floor(Math.random()*pool.length), 1)[0];
            board.push({ ...slot, char: pattern.char, color: pattern.c, id: board.length, removed: false });
        }
        return board;
    }

    function checkMoves() {
        const active = tilesData.filter(t => !t.removed);
        const selectable = active.filter(t => isSelectable(t, active));
        let count = 0; const counts = {};
        selectable.forEach(t => { const k = t.char + t.color; counts[k] = (counts[k] || 0) + 1; });
        for (let k in counts) count += Math.floor(counts[k]/2);
        return count;
    }

    function render() {
        const container = document.getElementById('tile-container');
        container.innerHTML = '';
        const off = getOffsets();
        tilesData.forEach(tile => {
            if (tile.removed) return;
            const el = document.createElement('div');
            el.className = `tile ${tile.selected ? 'selected' : ''}`;
            el.setAttribute('data-z', tile.z);
            el.style.width = TILE_W + 'px'; el.style.height = TILE_H + 'px';
            el.style.left = (tile.x * GAP_X + off.x) + 'px';
            el.style.top = (tile.y * GAP_Y + off.y) + 'px';
            el.style.zIndex = tile.z * 10;
            el.style.setProperty('--glow-color', tile.color);
            
            // SVG textを使って漢字を描画（レスポンシブ対応）
            el.innerHTML = `
                <svg viewBox="0 0 100 100" width="100%" height="100%">
                    <text x="50" y="58" text-anchor="middle" dominant-baseline="middle" 
                          class="tile-text" font-size="70" fill="${tile.color}">
                        ${tile.char}
                    </text>
                </svg>`;
            
            el.onclick = () => { playSound('select'); handleTileClick(tile); };
            container.appendChild(el);
        });
        const m = checkMoves();
        document.getElementById('counter').innerText = remaining;
        document.getElementById('moves').innerText = m;
        if (remaining === 0) document.getElementById('complete-screen').style.display = 'flex';
        else if (m === 0) document.getElementById('fail-screen').style.display = 'flex';
    }

    function handleTileClick(tile) {
        const active = tilesData.filter(t => !t.removed);
        if (!isSelectable(tile, active)) return;
        if (!selectedTile) { tile.selected = true; selectedTile = tile; }
        else if (selectedTile.id === tile.id) { tile.selected = false; selectedTile = null; }
        else if (selectedTile.char === tile.char && selectedTile.color === tile.color) {
            tile.removed = selectedTile.removed = true; selectedTile = null; remaining -= 2; playSound('match');
        } else { selectedTile.selected = false; tile.selected = true; selectedTile = tile; }
        render();
    }

    window.addEventListener('resize', () => { initMatrix(); updateScale(); render(); });
    initMatrix();
    setInterval(drawMatrix, 50); // 更新頻度高め（スムーズに）
    updateScale();
    tilesData = generateBoard();
    render();
</script>
</body>
</html>
